### rabbitmq tests
Это перевод статьи https://medium.com/@odelucca/recommendation-algorithm-using-python-and-rabbitmq-part-2-connecting-with-rabbitmq-aa0ec933e195,
а также мои примечания т.к. легко стартануть у меня не
получилось, да и мои знания английского оставляют 
желать лучшего.

---

На прошлой неделе мы говорили о том, как создать 
рекомендательную архитектуру. Мы поняли, как брокер 
сообщений может помочь нам создать масштабируемый и 
эффективный механизм рекомендаций. Мы также увидели 
довольно хороший GIF, чтобы на практике понять, как 
работает брокер сообщений. Теперь пришло время 
погрузиться глубже и начать общаться с реальным 
брокером сообщений.

Для начала давайте узнаем больше о RabbitMQ. Как я 
уже сказал, это брокер сообщений, который использует 
протокол AMQP для обмена сообщениями между двумя 
различными службами. В двух словах, протокол AMQP - 
это промежуточное ПО с четырьмя основными функциями: 
ориентация сообщений, организация очередей, 
маршрутизация и надежность. Использование AMQP 
означает использование плагина, который позволит 
вашим службам соединяться друг с другом на сервере 
по этому протоколу. Существуют разные подходы к 
соединению с сервером AMQP, и мы собираемся 
использовать RabbitMQ.

В заключение, AMQP - это протокол, а RabbitMQ - 
брокер, использующий протокол AMQP. Вы можете 
подключиться к RabbitMQ разными способами. 
Вы можете запустить свой собственный сервер 
RabbitMQ с помощью Docker или использовать 
веб-решение.

В этой статье мы будем использовать быстрое и 
простое веб-решение: CloudAMQP. Это компания, 
которая предоставляет вам «RabbitMQ как услугу». 
Их решение великолепно. Они безопасны, доступны, 
быстры и довольно просты в использовании. Наконец, 
что не менее важно, у них есть отличный бесплатный 
план, который охватывает гораздо больше, чем нам 
нужно для этого.

Чтобы построить наш проект, вам необходимо понять 
некоторые основные концепции RabbitMQ:

* Очереди: я накрыл почти все об этом на прошлой 
неделе. Очереди RabbitMQ подобны любой очереди, 
которую вы можете себе представить. Это 
упорядоченный список объектов, который соответствует 
методу FIFO (первым пришел, первым вышел). Каждая 
очередь должна прослушиваться или подписываться как 
минимум одним работником.

* Рабочие: они выполняют вычисления в архитектуре 
RabbitMQ. Работник - это служба, которая выполняет 
только одну конкретную задачу. Обычно они слушают 
или подписываются на очередь RabbitMQ для получения 
новых сообщений. Вы можете иметь несколько 
работников, слушающих одну и ту же очередь, но 
сообщения всегда будут доставляться только первому 
доступному работнику.

* Подписка: это действие, которое выполняет работник. 
Когда работник подписывается на очередь, это означает, 
что он ожидает новых сообщений в этой очереди, чтобы 
запустить определенную функцию. Подписанный работник 
не будет синхронизироваться с отправителем сообщения. 
Он просто получит сообщения из очереди и запустит 
функцию.

* Прослушивание: в отличие от подписки, прослушивание 
очереди означает, что работник синхронизируется с 
отправителем сообщения, чтобы что-то вернуть. Как я 
уже говорил, это не очень хорошая практика, но в 
некоторых случаях у вас не осталось других вариантов.

* Отправитель: это служба, которая отвечает за 
отправку сообщения. Важно знать, что работник также 
может быть отправителем для другой очереди.

* Публикация: это действие, которое выполняет 
отправитель. Когда отправитель публикует сообщение в 
очереди, это означает, что он пытается просто добавить 
это сообщение в очередь, не ожидая возврата от 
работника.

* Отправка: в отличие от публикации, отправка 
означает, что отправитель ожидает возврата от 
работника. Важно отметить, что RabbitMQ будет 
действовать иначе, если вы опубликуете или 
отправите сообщение.

Я думаю, что теперь мы рассмотрели все основы 
возможностей RabbitMQ. Есть много дополнительной 
информации об этом, которую вы можете проверить в их 
документации. Но знание основных концепций, которые 
я перечислил выше, даст вам основную идею этой 
архитектуры, и вы будете готовы создавать простые 
приложения, используя ее.

### Что мы собираемся делать?

Наша цель в этой статье - разработать модуль Python, 
который может соединяться с сервером RabbitMQ для 
отправки и получения данных с него. Обратите 
внимание на ключевое слово здесь: модуль. Это важно, 
потому что, поскольку мы разрабатываем архитектуру 
микросервисов, существует много сервисов, которые 
должны будут использовать эту библиотеку. Хороший 
разделяемый код означает хорошее понимание входов и 
выходов нашего кода. На мой взгляд, лучший способ 
добиться этого - использовать процесс TDD.

### Подождите ... Что такое TDD?

Короче говоря, TDD (разработка через тестирование) - 
это процесс разработки, ориентированный на 
тестирование. Вместо того, чтобы кодировать ваше 
приложение с нуля, в TDD вы начинаете с кодирования 
тестов вашего приложения. Вы можете использовать 
множество пакетов, чтобы помочь вам при написании 
этих тестов, но с помощью автоматизированного 
тестирования проще кодировать и поддерживать ваши 
приложения. Сначала это будет сложно. Трудно 
изменить свое мышление, и вы будете кодировать 
намного медленнее. Но со временем вам будет сложнее 
писать код без тестов.

Тестирование - одна из самых ценных лучших практик. 
Это помогает вашему коду быть более масштабируемым 
и стабильным. Теперь давайте немного разберемся, как 
писать тесты. Существует 3 основных типа тестов:

1. Модульные тесты: они проверяют логику вашего кода. 
Вы проверяете каждую функцию в отдельности, 
проверяете любые интеграции и утверждаете, что 
каждый раз, когда вы вводите некоторые данные, вы 
получаете ожидаемый результат. Это очень 
низкоуровневый тест, и обычно у вас есть отдельный 
файл для каждой части вашего кода.

2. Интеграционные тесты: они тестируют некоторые 
большие интегрированные области вашего кода. Вы 
можете смоделировать некоторые другие части вашего 
приложения, но идея состоит в том, чтобы 
протестировать «часть» вашего приложения, 
интегрированную с каждой зависимостью этой функции. 
Например, на веб-сайте бронирования тест на 
интеграцию подтвердит, что ваша функция оформления 
заказа работает должным образом.

3. Сквозные (приемочные) тесты: это самый крупный и 
более дорогой автоматический тест (хотя он намного 
дешевле ручного тестирования). В сквозном тесте вы 
пишете код для тестирования всего приложения.

Хорошо, это TDD 101. Все еще есть много, чтобы 
покрыть, если вы хотите узнать больше об этом, но я 
напишу кое-что об этом в будущем.

Вы, наверное, заметили, что я только что написал о 
функциях. Но как насчет классов и ООП? Я собираюсь 
написать эту программу с функциональным 
программированием.

### Функциональное программирование

Это также очень большая тема, но функциональное 
программирование - это парадигма, которая 
рассматривает вычисления как серию функций. Вместо 
того, чтобы писать объекты и использовать потом, мы 
собираемся писать функции. Это намного проще для 
тестирования, а также имеет много преимуществ, 
таких как устранение побочных эффектов.

Хотя Python в первую очередь является 
объектно-ориентированным языком, его можно 
использовать в качестве функционального языка, и 
это то, что мы собираемся сделать здесь ».

### Еще кое-что…

На мой взгляд, наибольшее преимущество TDD - думать 
о проблеме перед кодированием. Итак, я думаю, что 
формулировка проблемы, которую мы пытаемся решить в 
первом приложении:

    Возвратите объект, который связан с определенным сервером 
    RabbitMQ и может прослушивать N очередей (запуск функции 
    при получении нового сообщения), а также 
    отправлять сообщение в любую заданную очередь.
    
So, the main features of this application are:

* Уметь создавать новое соединение RabbitMQ (что-то 
вроде шаблона фабричного дизайна)
* Иметь возможность прослушивать очередь, выполняя 
функцию каждый раз, когда получает новое сообщение
* Соотношение между очередями и функциями должно 
быть один ко многим. Например, каждая 
прослушиваемая очередь должна иметь только одну 
функцию-обработчик, но функции могут обрабатывать 
любое количество очередей.
* Быть в состоянии отправить сообщение в заданную 
очередь

Это выглядит хорошо. Я думаю, что мы рассмотрели 
все основные функции нашего приложения. Поскольку 
мы разрабатываем модуль, важно иметь хорошую 
организацию папок. Для этого мы будем использовать 
следующее:

    RabbitMQ-Python-Adapter-1.0.0/
    │
    ├── rabbitmq-adapter/
    │ ├── __init__.py
    │ └── # Any other file of our module
    │
    ├── config/
    │ ├── config.py
    │ └── # Any config file
    │
    ├── tests/
    │ ├── __init__.py
    │ └── # All integration and unit tests
    │
    ├── .gitignore
    ├── LICENSE
    ├── README.md
    └── requirements.txt

    * Эта структура папок основана на одной 
    Жан-Полем Кальдероне    

Просто несколько сносок. Хорошей практикой является 
использование имени вашего модуля с версией его (я 
использую SemVer в качестве шаблона управления 
версиями) и создание папки, в которой находится 
только имя вашего модуля. В этой структуре легче 
организовать ваши файлы и применить дизайн, 
управляемый доменом, в вашем коде. Кроме того, я 
поместил наши тестовые файлы за пределы папки модуля, 
поскольку при развертывании дешевле удалить всю 
тестовую папку при развертывании в рабочей среде.

### В КОНЦЕ КОНЦОВ! Давайте кодировать что-то

Каждый раз, когда я начинаю новый проект, мне 
нравится записывать некоторые основные 
интеграционные тесты. Это помогает мне понять, что 
мне нужно сделать, и организовать свои мысли. 
Первое, что я делаю, это просто записываю тестовые 
утверждения. Я использую Pytest в качестве основы 
тестирования.

    ## tests/test_integration.py
    def test_rabbitmq_factory():
        # Должно быть в состоянии создать соединение RabbitMQ
        assert True

    def test_rabbitmq_listen_to_queue():
        # Должен быть в состоянии слушать очередь RabbitMQ
        assert True

    def test_rabbitmq_queue_one_to_many_queue_handler():
        # Должно быть в состоянии иметь отношение «один ко многим» между очередью и функцией-обработчиком.
        assert True

    def test_rabbitmq_send_message():
        # Должен быть в состоянии отправить сообщение в заданной очереди
        assert True
    
Как видите, я еще не написал ни одного теста. Обычно 
так я запускаю проект TDD. Я просто пишу тестовые 
функции, затем начинаю их разрабатывать. Это хороший 
способ организовать процесс кодирования.

Теперь, чтобы запустить этот тест, вам нужно 
установить платформу Pytest. Это довольно легко, 
просто запустите pip install -U pytest, и он 
запустит установку. Если у вас есть какие-либо 
проблемы, вы можете проверить их документы.

После завершения установки перейдите в свой терминал, 
в корневой папке проекта и просто запустите pytest. 
Это запустит ваши тесты. Каждый файл, который 
начинается с `test_*`, будет сопоставлен и запущен.

Ну, так как все утверждает True, вы получите результат 
успеха, как этот:

    ....
    KeyError: 'PWD'

Это если набирать команду в PyCharm, можно конечно
набрать команду `set PWD=`, но лучше вбить эту 
переменную для начала в настройках `CTRL-ALT-S>Tools>Terminal`

После того как появилась переменая `PWD` запуск 
`pytest` должна закончиться удачно:

    ============== test session starts ==============
    platform win32 -- Python 3.7.7, pytest-5.4.1, py-1
    .8.1, pluggy-0.13.1
    rootdir: E:\python\rabbitmq_first, inifile: pytest
    .ini
    plugins: env-0.6.2
    collected 4 items                                

    tests\test_integration.py ....             [100%]

    =============== 4 passed in 0.03s ===============

Теперь нам нужно написать несколько реальных тестов. 
Первое, что мы собираемся сделать, это написать 
фабрику. Для этого я собираюсь написать test_channel. 
Этот тест должен создать новый канал RabbitMQ.

    ## tests/test_channel.py
    import pytest
    import rabbitmq_adapter
    import sys
    import os
    from unittest.mock import Mock
    from tests.__mocks__ import pika
    
    sys.path.append(os.environ['CONFIG'])
    from config import *
    
    @pytest.mark.unit
    def test_channel_sets_parameters(monkeypatch):
        mocked_pika = Mock()
        mocked_pika.URLParameters.return_value = 'MORTY'
        monkeypatch.setattr('rabbitmq_adapter.channel.pika', mocked_pika)
    
        rabbitmq_adapter.channel.create('MORTY HOST')
    
        mocked_pika.URLParameters.assert_called_once_with('MORTY HOST')
    
    @pytest.mark.unit
    def test_channel_creates_connection(monkeypatch):
        mocked_pika = Mock()
        mocked_pika.URLParameters.return_value = 'MORTY'
        mocked_pika.BlockingConnection.return_value = pika.Connection()
        monkeypatch.setattr('rabbitmq_adapter.channel.pika', mocked_pika)
    
        rabbitmq_adapter.channel.create('MORTY HOST')
    
        mocked_pika.BlockingConnection.assert_called_once_with('MORTY')
        
В первых 6 строках мы просто импортируем каждую 
зависимость для запуска этого теста. Вы, наверное, 
заметили здесь некоторые неизвестные имена: 
unittest.mockand tests .__ mocks__. Первая - 
это библиотека для насмешки для Python. Он уже 
встроен в вашу установку Python. Mocking - 
это метод тестирования, при котором вы обходите 
использование функции, возвращающей любые выбранные 
вами данные. Например, в этом тесте мы собираемся 
смоделировать использование Pika 
(внешней библиотеки). Каждый раз, когда тестируемая 
функция вызывает макетированную функцию, они не 
будут вызываться и вместо этого будут возвращать 
то, что мы выбрали. Второй неизвестный 
импортированный lib - это тесты .__ mock__. Это где 
я положил все мои издевательства, чтобы 
использовать их снова. Это хорошая практика.

Макет, который мы собираемся использовать, - макет 
Пика (импортирован в строку 6). Pika - чистая 
реализация Python протокола AMQP. Это помогает нам 
связаться с нашим сервером RabbitMQ. Мы собираемся 
больше поговорить об этих параметрах библиотеки в 
будущем. Сейчас вам нужно понять, что для нашего 
теста нам нужно смоделировать эту библиотеку, чтобы 
протестировать наши сценарии. Вот код для этого:

    ## tests/__mocks__/pika.py
    class Channel:
        def __init__(self): pass
        def exchange_declare(self): pass
        def queue_declare(self): pass
        def queue_bind(self): pass
        def basic_qos(self): pass
        def basic_consume(self): pass
        def start_consuming(self): pass
        def basic_publish(self): pass
        def basic_ack(self): pass
    
    class Connection:
        def __init__(self): pass
        def channel(self): return Channel()
        
В строках 8 и 9 я импортирую свои конфиги. Обычно я 
помещаю всю конфигурацию в файл YAML в папку config. 
Для этого я установил абсолютный путь к моей папке 
конфигурации в переменной среды CONFIG. Кроме того, 
мне нужно создать скрипт config.py для импорта 
правильной конфигурации среды. Для этого модуля нам 
понадобится только конфигурация тестирования, потому 
что почти каждая конфигурация будет исходить из того, 
какая функция вызывает наш модуль. Теперь вам нужно 
создать файл config.py внутри вашей папки config:

    import os
    import yaml
    from pathlib import Path
    from dotmap import DotMap
    
    def load_only_current_env(config):
        configs = yaml.load(config)
        return configs[os.environ['ENV']]
    
    config_files = [os.path.join(r, file) for r, d, f in os.walk(os.environ['CONFIG']) for file in f if '.yaml' in file]
    config = DotMap({Path(cfg).stem: load_only_current_env(open(cfg, 'r')) for cfg in config_files})

Это довольно простой скрипт. Он просто получает все 
файлы yaml из папки config и загружает их. Кроме 
того, я обычно создаю параметр внутри каждой 
конфигурации для следующих сред: тестирование, 
разработка, подготовка и производство. После этого 
просто сделайте flatten, удалив параметр env и 
сохранив только его содержимое. Я не буду вдаваться 
в подробности, но если вы хотите, я могу сделать 
еще одну статью в будущем, посвященную этому 
сценарию.

Теперь вам нужно создать файл rabbitmq.yaml:

    test:
      host: '<put-your-cloudamqp-server-string-here>'
  
Это очень простой конфигурационный файл. В более 
крупном проекте у вас будет свой объект для каждой 
среды.

Теперь нам нужно добавить pyyaml и dotmap как 
зависимости к нашим проектам (не забудьте 
запустить `pip install -r requirements.txt` для их 
установки). Наш файл requirements.txt может выглядеть 
так:

    pytest
    pyyaml
    dotmap

Возвращаясь к нашему файлу test_channel.py, строки 
11, 21 и 32 являются маркерами Pytest. Это 
метаданные, которые вы можете использовать для 
взаимодействия с самим Pytest. Идея здесь состоит в 
том, чтобы определить, является ли следующий тест 
модульным или интеграционным тестом. Интеграционные 
тесты обычно выполняются дольше, чем модульные тесты. 
Таким образом, вы можете просто запускать только 
модульные тесты в структуре CD. Для этого вместо 
запуска pytest вы можете запустить pytest -m unit, 
а затем он будет проверять только те функции, 
которые помечены как unit.

Но для работы с пользовательскими маркерами вам 
нужно изменить свой pytest.ini. Это файл, который вы 
помещаете в корень вашего проекта, со следующим 
содержанием:

    [pytest]
    markers =
      integration
      unit
    env =
      ENV=test
      CONFIG=../config/
      
Чтобы сделать нашу жизнь проще, я также добавил 
некоторые переменные среды, которые мы используем: 
ENV и CONFIG. Но у Pytest по умолчанию нет этой 
конфигурации env ini. Вам нужно установить 
библиотеку pytest-env. Теперь наш requirements.txt 
будет выглядеть так:      

    pytest
    pytest-env
    pyyaml
    dotmap

Возвращаясь к нашему тесту, в строке 12 мы начинаем 
писать первый модульный тест. Идея сценария канала 
заключается в создании канала Pika, который может 
взаимодействовать с нашим сервером RabbitMQ. Для 
этого нам необходимо:

1. Инициализировать наши параметры Пика
2. Заблокировать соединение
3. Вернуть канал

Возможно, вы заметили, что в наших тестах мы 
получаем параметр monkeypatch. Это приспособление, 
которое помогает вам издеваться над функциями. 
Чтобы использовать его, вам просто нужно добавить 
этот параметр в ваши тесты.

Переходя к строке 13, мы теперь создали Mock, 
используя функцию Mock unittest. В строках 14 и 15 
мы смоделировали метод Pika URLParameters, чтобы он 
возвращал ложные данные (мне нравится использовать 
имена Morty в качестве данных тестовых данных), и 
они устанавливают в наш monkeypatch макет всего, 
что импортируется из нашего проверенного скрипта, 
как библиотеку Pika для вызова. вместо этого наш 
макет (в строке 15).

Наконец, мы запускаем наш протестированный скрипт в 
строке 17 и проверяем, был ли вызван 
mocked_pika.URLParameters со строкой хоста, которую 
мы отправили скрипту в строке 19.

Это все для первого модульного теста. Второй 
начинается в строке 22. Это примерно то же самое 
при инициализации и выполнении, от строки 23 до 
строки 28. Разница в том, что теперь мы также 
добавили фиктивный возврат для 
pika.BlockingConnection. В конце этого теста, в 
строке 30, мы утверждаем, что 
pika.BlockingConnection вызывается с поддельным 
возвратом из pika.URLParameters.

Теперь если наполнить файл `rabbitmq_adapter/channel.py`
содержимым, то юнит тесты пройдут успешно:

    import pika
    
    def create(host):
        params = pika.URLParameters(host)
        connection = pika.BlockingConnection(params)
    
        return connection.channel()

Теперь мы собираемся разработать наш интеграционный 
тест. Для этого вам понадобится действующий сервер 
RabbitMQ. Установите rabbitmq локально и пропишите
в настройки `rabbitmq.yaml`:

    test:
      host: 'amqp://localhost'
      exchange: 'amq.direct'
      queue: 'TEST::NEW'
      prefetch:
        count: 1

Теперь нам просто нужно закончить наши 
интеграционные тесты. Вот код для нашего тестового 
файла:

    import pytest
    import rabbitmq_adapter
    import sys
    import os
    from time import sleep
    
    sys.path.append(os.environ['CONFIG'])
    from config import *
    
    def setup_listener(
        channel,
        on_message_callback,
        queue=config.rabbitmq.queue,
        exchange=config.rabbitmq.exchange,
        durable=False,
        prefetch_count=config.rabbitmq.prefetch.count
    ):
        channel.queue_declare(queue=queue, durable=durable)
        channel.queue_bind(queue=queue, exchange=exchange)
        channel.basic_qos(prefetch_count=prefetch_count)
        channel.basic_consume(queue=queue, on_message_callback=on_message_callback)
    
        return channel
    
    def wait_for_result(
        anchor,
        tries=0,
        retry_after=.6
    ):
        if len(anchor) > 0 or tries > 5: assert len(anchor) > 0
        else:
            sleep(retry_after)
            return wait_for_result(anchor, tries + 1)
    
    @pytest.mark.integration
    def test_rabbitmq_factory():
        # Should be able to create a RabbitMQ connection
        calls = []
        def mocked_handler(ch, method, props, body):
            calls.append(1)
            ch.basic_ack(delivery_tag=method.delivery_tag)
            ch.close()
    
        rabbitmq_channel = rabbitmq_adapter.channel.create(config.rabbitmq.host)
        rabbitmq_channel = setup_listener(rabbitmq_channel, mocked_handler)
        rabbitmq_channel.basic_publish(
            exchange=config.rabbitmq.exchange,
            routing_key=config.rabbitmq.queue,
            body='MORTY'
        )
    
        rabbitmq_channel.start_consuming()
        wait_for_result(calls)
    
    def test_rabbitmq_listen_to_queue():
        # Should be able to listen to a RabbitMQ queue
        assert True
    
    def test_rabbitmq_queue_one_to_many_queue_handler():
        # Should be able to have an one-to-many relationship between the queue and the handler function
        assert True
    
    def test_rabbitmq_send_message():
        # Should be able to send a message in a given queue
        assert True

Первые восемь строк практически совпадают с 
юнит-тестами. Мы просто импортируем некоторые 
библиотеки и скрипты. От строки 10 до 33 я объявил 
две функции, которые помогут нам во многих сквозных 
тестах. Первый добавляет слушателя внутри созданного 
канала. Я не буду подробно объяснять эту функцию, 
потому что мы собираемся исследовать ее в следующих 
тестах. Второй повторяется через 600 мс, чтобы 
проверить, был ли вызван слушатель. Нам нужен этот, 
потому что мы используем внешнюю службу, для ответа 
которой требуется некоторое время. Поэтому нам 
нужно время от времени проверять, был ли вызван наш 
обработчик.

Обратите внимание, что в строке 35 я пометил этот 
тест как интеграцию. Возвращаясь к нашему тестовому 
файлу, идея этого интеграционного теста состоит в 
том, чтобы создать новый канал и проверить, можем 
ли мы отправлять и получать в нем сообщение. Для 
этого мы собираемся создать простую 
функцию-обработчик для обработки новых сообщений и 
отправки данных в очередь прослушивания этой функции.

Идея теста со строк от 36 до 53 состоит в том, 
чтобы создать канал и, используя этот канал, 
создать слушателя в очереди, попытаться отправить 
сообщение и посмотреть, получил ли слушатель его. 
Мы не будем углубляться в это, потому что в 
основном я делаю в тесте то, что должен делать весь 
наш модуль. По этой причине я собираюсь рассказать 
о слушателях и отправке сообщений при разработке 
следующих сценариев.

Круто! Теперь вы почти закончили выполнять свой 
первый тест. Перед этим нам просто нужно разработать 
код, который мы собираемся протестировать.

На первой линии мы только что импортировали пакет 
Pika. Как я уже сказал, эта библиотека будет 
обрабатывать соединение между нашими скриптами и 
сервером RabbitMQ. Помните, что этот пакет будет 
проверен во время наших юнит-тестов.

Теперь наш файл requirements.txt выглядит так:

    pytest
    pytest-env
    pyyaml
    dotmap
    pika

````

    import pika
    
    def create(host):
        params = pika.URLParameters(host)
        connection = pika.BlockingConnection(params)
    
        return connection.channel()
    
````

В строке 4 мы создали параметры подключения и 
используем их в строке 5 для создания нашего 
подключения. Наконец, мы возвращаем канал связи в строке 7.

Еще одна вещь, нам нужно добавить этот скрипт в наш 
файл __init__.py, чтобы функции этого скрипта были 
доступны для импорта. Вы можете сделать это, 
добавив следующие строки в rabbitmq_adapter 
/ __ init__.py:

    import rabbitmq_adapter.channel
    
Ура! Just Вы только что закончили первую часть 
вашего модуля RabbitMQ. Теперь нам нужно заполнить 
следующий контрольный список функций:

* Уметь создавать новое соединение RabbitMQ (что-то 
вроде шаблона фабричного дизайна) → (готово)

* Иметь возможность прослушивать очередь, выполняя 
функцию каждый раз, когда получает новое сообщение

* Соотношение между очередями и функциями должно 
быть один ко многим. Например, каждая 
прослушиваемая очередь должна иметь только одну 
функцию-обработчик, но функции могут обрабатывать 
любое количество очередей.

Теперь наша цель - разработать сценарий, который 
для заданного канала может прослушивать 
определенную очередь и отправлять каждое сообщение 
в функцию-обработчик, верно? Вот шаги, которые мы 
должны предпринять для прослушивания очереди:

* Объявите очередь: это не интуитивно понятно, но мы 
можем прослушивать только те очереди, которые уже 
созданы на нашем сервере. Итак, если мы попытаемся 
прослушать несуществующую очередь, наш скрипт выдаст 
ошибку.

* Привязать к очереди: для прослушивания очереди 
нам необходимо связать эту очередь с обменом. 
Обмен - это в основном набор правил для 
упорядочения сообщений между отправителями и 
получателями. Существует четыре типа обмена: прямой, 
тематический, заголовки и разветвление. Я не буду 
углубляться в это, но мы собираемся использовать 
прямой обмен.

* Задайте количество неподтвержденных сообщений: 
эта точка указывается параметром basic_qos. Идея 
состоит в том, чтобы установить, сколько сообщений 
служба получит от сервера RabbitMQ.

* Начните потреблять новые сообщения: это 
действительно интуитивно понятно, оно в основном 
начинает получать сообщения и отправлять их в 
функцию-обработчик.

Мы собираемся начать с настройки наших модульных 
тестов:

    import pytest
    import rabbitmq_adapter
    import sys
    import os
    from unittest.mock import Mock
    from tests.__mocks__ import pika
    
    sys.path.append(os.environ['CONFIG'])
    from config import *
    
    def mocked_handler(): pass
    
    @pytest.mark.unit
    def test_listener_subscribe_queue_declared(monkeypatch):
        channel = pika.Channel()
        channel.queue_declare = Mock()
    
        rabbitmq_adapter.listener.subscribe(channel, mocked_handler)
    
        channel.queue_declare.assert_called_once_with(
            queue=config.rabbitmq.queue,
            durable=True
        )
    
    @pytest.mark.unit
    def test_listener_subscribe_queue_bind(monkeypatch):
        channel = pika.Channel()
        channel.queue_bind = Mock()
    
        rabbitmq_adapter.listener.subscribe(channel, mocked_handler)
    
        channel.queue_bind.assert_called_once_with(
            queue=config.rabbitmq.queue,
            exchange=config.rabbitmq.exchange
        )
    
    @pytest.mark.unit
    def test_listener_subscribe_basic_qos(monkeypatch):
        channel = pika.Channel()
        channel.basic_qos = Mock()
    
        rabbitmq_adapter.listener.subscribe(channel, mocked_handler)
    
        channel.basic_qos.assert_called_once_with(prefetch_count=config.rabbitmq.prefetch.count)
    
    @pytest.mark.unit
    def test_listener_subscribe_basic_consume(monkeypatch):
        channel = pika.Channel()
        channel.basic_consume = Mock()
    
        rabbitmq_adapter.listener.subscribe(channel, mocked_handler)
    
        channel.basic_consume.assert_called_once_with(
            queue=config.rabbitmq.queue,
            on_message_callback=mocked_handler
        )

Давайте рассмотрим наш код. Первые 9 строк такие же, 
как и в предыдущем тесте. Мы просто импортируем 
некоторые основные зависимости. Ничего нового. В 
строке 11 у нас есть что-то другое: простая 
функция-обработчик для использования в нашем тесте. 
Эта функция ничего не выполняет.

Теперь, в нашем первом тесте, который проходит со 
строки 15 до 23, мы проверяем, объявляет ли наш код 
очередь. Мы начинаем с создания нового канала, они 
издеваются над нашей функцией queue_declare, а 
затем запускаем наш скрипт. После этого мы 
утверждаем, что он был вызван с использованием 
ожидаемых нами параметров (очереди и длительности). 
Параметр durable здесь очень прост, он говорит, что 
очередь все еще должна сохраняться, когда ее не 
слушает ни одна служба.

Наш второй тест, который идет от строки 27 до 35, 
проверяет, привязывает ли наш скрипт очередь к 
желаемому обмену. Это почти та же структура, что и 
в первом тесте: мы настраиваем канал, смоделируем 
queue_bind, запускаем скрипт и проверяем, получили 
ли наши проверенные функции правильные параметры 
(очередь и обмен).

В третьем тесте, который проходит со строки 39 до 44, 
мы проверяем, вызывает ли наш скрипт функцию 
basic_qos. Он имеет ту же структуру, что и другие 
тесты.

В нашем последнем модульном тесте, который проходит 
со строки 48 до 56, мы проверяем, начинает ли наш 
скрипт принимать новые сообщения. Также с такой же 
тестовой структурой.
